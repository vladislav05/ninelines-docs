# Советы для оптимизации производительности сайта

В данном разделе документации собраны некоторые советы для разработки, которые помогут улучшить производительность сайта.

# 1. Оптимизация растровых изображений

Формат изображений выбираем отталкиваясь от прозрачности, если прозрачность присутствует - png, если ее нет - jpg. Картинки формата jpg получаются более легкими и лучше сжимаются. Конечно есть случаи, где требуется использовать тот или иной формат по мере надобности.

Используйте **srcset** для выбора необходимого изображения под нужное разрешение.

```html
<img src="/images/example.jpg" srcset="/images/example-retina.jpg 2x" alt="image">
```

Картинки должны быть сжаты, для этого можно использовать любой онлайн сервис или ПО для сжатия картинок. Конкретного предпочтения по сервисам нет, главное чтобы после сжатия картинки не слишком теряли качество. Вот небольшой список онлайн сервисов:

+ <https://tinypng.com>
+ <https://imagecompressor.com>
+ <https://compressor.io>
+ <https://imagify.io>
+ <https://kraken.io>

# 2. Оптимизация JavaScript кода

Некоторые советы, которые помогут оптимизировать работу скриптов.

## 2.1 Кеширование выборки и вычислений

Кеширование позволяет сократить кол-во обращений к дом-узлам или сократить кол-во вычислений, сделав это всего один раз и записав в память.

**неправильно**

```js
let $header = $('.header');
let $headerNav = $('.header__nav');
let $headerItem = $('.header__item')

function getItemTopPosition() {
  $headerItem.each((index, item) => {
    let itemTopPosition = $header.height() / 2 -   $(item).offset().top;

    console.log(itemTopPosition);
  });
}
```

**правильно**

```js
let $header = $('.header');
let $headerNav = $header.find('.header__nav');
let $headerItem = $headerNav.find('.header__item');

let headerHalfHeight = $header.height() / 2;

function getItemTopPosition() {
  $headerItem.each((index, item) => {
    let itemTopPosition = headerHalfHeight - $(item).offset().top;

    console.log(itemTopPosition);
  });
}
```

## 2.2 Чистка обработчиков событий

В наших проектах мы часто используем роутер, поэтому создаем функции для инициализации страницы на которую переходим. В функции инициализации вешаются обработчики на элементы и часто их забывают отключать. Получается такая ситуация - перешли на страницу первый раз, повесились обработчики. Ушли со страницы и вернулись еще раз, произошла инициализация и обработчики повесились еще раз и т.д. В итоге при выполнении какого-то события оно будет отработано несколько раз. Для предотвращения такой ситуации можно сделать так:

```js
function initPage() {
  $('.element')
    .off('.some-event')
    .on('click.some-event', () => {
      // do smth
    });
}
```

Или создать функцию сброса параметров после ухода со страницы, в которой можно не только сбрасывать обработчики но и обнулять какие-то вычисления.

```js
let currentPage = null;
let pageHeight = null;

function initPage(page) {
  let $page = $(page);

  currentPage = $page;
  pageHeight = $page.height();

  $page.on('scroll.page', () => {
    // do smth
  });
}

function resetPage() {
  currentPage.off('.page');

  currentPage = null;
  pageHeight = null;
}
```

Ситуации бывают разные, поэтому необходимо следить за тем, чтобы обработчики не дублировались, иначе двойные, тройные … n-ые вычисления могут привести к значительному снижению производительности.

## 2.3 Использование throttle

Существуют ситуации когда нам необходимо делать какие-то ресурсоемкие вычисления например на движение мыши или скролл. Для того, чтобы снизить нагрузку мы можем использовать **throttle** - функция, которая позволяет выполнить какое-то действие с задержкой в заданное кол-во времени. Подробнее можно почитать [здесь](https://learn.javascript.ru/task/throttle) или “покурить” гугл. Приведу небольшой пример.
Здесь функция **getScrollPercentProgress** будет выполняться каждый раз при скролле как только браузер сможет обработать этот код.

```js
function getScrollPercentProgress() {
  return (pageYOffset + innerHeight) / document.body.clientHeight * 100;
}

window.onscroll = () => {
  console.log(getScrollPercentProgress());
};
```

Здесь же **getScrollPercentProgress** будет вызываться каждые 100мс, тем самым снижая кол-во выполнений. Также для уменьшения вычислений создаем сразу две переменные, которые будут хранить высоту окна и высоту документа.

```js
let windowHeight = innerHeight;
let documentHeight = document.body.clientHeight;

function getScrollPercentProgress() {
  return (pageYOffset + windowHeight ) / documentHeight * 100;
}

window.onscroll = throttle(() => {
  console.log(getScrollPercentProgress());
}, 100);
```

## 2.4 Использование debounce

**Debounce** позволяет отложить вызов функции, пока не пройдет заданный промежуток времени с момента последнего вызова, например:

В данном случае функция **rebuildSmth** будет выполняться непрерывно, пока мы меняем размер окна.

```js
function rebuildSmth() {
  $('.elements').height(innerHeight);
 // здесь выполняется какой-то супер сложный код
}

window.onresize = rebuildSmth;
```

А здесь она выполнится один раз, через 500 мс с момента последнего изменения размера.

```js
let windowHeight = innerHeight;
let $elements = $('.elements');

function rebuildSmth() {
  $elements.height(innerHeight);
 // здесь выполняется какой-то супер сложный код
}

window.onresize = debounce(rebuildSmth, 500);
```

# 3. Оптимизация CSS-кода

Касаемо производительности css все намного проще. Главное, что стоит запомнить - браузер читает селекторы справа налево и порядок селекторов по производительности (от более производительных к менее):

1. идентификатор (#block)
2. класс (.block)
3. тип (div)
4. сосед по уровню (h1 + p)
5. дочерний элемент (div > ul)
6. вложенный элемент (div a)
7. общий селектор (*)
8. атрибут ([type=”button”])
9. псевдоклассы/псевдоэлементы (a:hover)

Выбор элементов в css влияет на производительность, в том числе, на то, как быстро отображается страница. Однако в реальном использовании разница совсем невелика и большого прироста производительности можно не ожидать.
Используйте простые css-селекторы, меньше вложений и короче цепочки. Идеальный вариант - прямые селекторы только по классу (.element), благо БЭМ это позволяет. Подобное правильно также хорошо подходит для выбора дом-узла в js.

**плохо**

```css
div ul li[data-type="link"] a {
  color: red;
}

div.article {
  display: block;
}

.article li a {
  text-decoration: none;
}

.article:last-child ul * {
  background: none;
}
```

**хорошо**

```css
.link {
  color: red;
}

.article {
  display: block;
}

.article__link {
  text-decoration: none;
}

.article__item {
  background: none;
}
```

# 4. Оптимизация анимации

## 4.1 Не анимируйте сложные свойства

На данный момент браузеры хорошо оптимизируют анимацию свойств **opacity** и **transform**. Анимирование остальных свойств лучше избегать или стараться использовать по минимуму, особенно это касается мобильных устройств.

**плохо**

```css
.menu {
  position: fixed;
  left: -100%;
  top: 0;
  background: transparent;
  transition: all 0.3s;
}

.menu.is-opened {
  left: 0;
  box-shadow: 10px 0 30px rgba(255, 255, 255, 0.3);
  background: #fff;
}
```

**хорошо**

```css
.menu {
  position: fixed;
  left: 0;
  top: 0;
  z-index: 1;
  transform: translate3d(-100%, 0, 0);
  transition: transform 0.3s;
}

.menu::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  z-index: -1;
  display: block;
  width: 100%;
  height: 100%;
  box-shadow: 10px 0 30px rgba(0, 0, 0, 0.3);
  background: #fff;
  opacity: 0;
  transition: opacity 0.3s;
}

.menu.is-opened {
  transform: none;
}

.menu.is-opened::before {
  opacity: 1;
}
```

Объем кода получается больше, однако производительность, особенно на мобильных и слабых устройствах, будет заметна. Также обратите внимание на свойство transition, всегда указывайте какие свойства элемента вам нужны для анимации, чтобы не анимировать сразу все.

## 4.2 Используйте requestAnimationFrame вместо setInterval

**RequestAnimationFrame (RAF)** лучше справляется с анимацией, чем интервал. Он хорошо оптимизирован браузерами и лучше экономит ресурсы, что немаловажно для мобильных и слабых устройств.

**плохо**

```js
let intervalId = setInterval(() => {
  // код вашей анимации

  if (i > 1000) {
    clearInterval(intervalId);
  }
}, 1000 / 60);
```

**хорошо**

```js
let rafId;

function animate() {
  rafId = requestAnimationFrame(animate);

  // код вашей анимации

  if (i > 1000) {
    cancelAnimationFrame(rafId);
  }
}

requestAnimationFrame(animate);
```

Поворот по оси Z помогает убрать лишние дергания анимации, особенно заметно в IE и Edge при анимации scale.

# 5. Другие решения

## 5.1 Lazy loading (ленивая загрузка)

В интернете много пояснений о том, что такое ленивая загрузка и как ее реализовать, если коротко - это способ загрузки данных по мере надобности.

Например в нашем случае, когда мы разрабатываем SPA, содержимое сайта загружается все и сразу т.е. мы ждем пока загрузятся все картинки, видео, фреймы и т.п. (со всех страниц), а их может быть очень много и вкупе они имеют большой вес. Благодаря ленивой загрузке можно сделать так, чтобы изначально загружались ресурсы только одной страницы или только те, которые пользователь увидит изначально на экране (плюс взять небольшой запас). Далее пользователь переходит по страницам, открывает попапы, переходит по секциям и т.д., и по мере надобности подгружаются недостающие ресурсы. Т.е. смысл в том, что мы не отдаем пользователю сразу все, а только то, что ему необходимо на данный момент.
